generator client {
  provider = "prisma-client-js"
  output   = "../src/generated/prisma"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

// ===================
// Enums del dominio
// ===================

enum Role {
  ADMINISTRADOR
  INMOBILIARIA
  GESTOR
  TECNICO
}

enum TipoLote {
  LOTE_VENTA
  ESPACIO_COMUN
}

enum EstadoLote {
  ALQUILADO
  DISPONIBLE
  EN_PROMOCION
  NO_DISPONIBLE
  RESERVADO
  VENDIDO
}

enum SubestadoLote {
  CONSTRUIDO
  NO_CONSTRUIDO
  EN_CONSTRUCCION
}

enum NombreCalle {
  REINAMORA
  MACA
  ZORZAL
  CAUQUEN
  ALONDRA
  JACANA
  TACUARITO
  JILGUERO
  GOLONDRINA
  CALANDRIA
  AGUILAMORA
  LORCA
  MILANO
}

enum EstadoVenta {
  INICIADA
  CON_BOLETO
  ESCRITURA_PROGRAMADA
  ESCRITURADO
}

// ===================
// Modelos de dominio
// ===================

// Usuario
model User {
  id        Int      @id @default(autoincrement())
  username  String   @unique
  password  String
  role      Role
  createdAt DateTime @default(now())
  persona   Persona?
  inmobiliaria Inmobiliaria?
}

// Persona
model Persona {
  id        Int       @id @default(autoincrement())
  nombre    String
  apellido  String
  cuil      String
  contacto  String?
  userId    Int?      @unique
  user      User?     @relation(fields: [userId], references: [id])
  lotes     Lote[]
  createdAt DateTime  @default(now())
  updateAt  DateTime
  Venta     Venta[]
  Reserva   Reserva[]
}

// Reserva
model Reserva {
  id             Int      @id @default(autoincrement())
  fechaReserva   DateTime
  loteId         Int
  clienteId      Int
  inmobiliariaId Int?
  sena           Decimal? @db.Decimal(12, 2) // “seña” opcional, pero al parecer asi es mejor
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  // relaciones
  lote         Lote          @relation(fields: [loteId], references: [id])
  cliente      Persona       @relation(fields: [clienteId], references: [id])
  inmobiliaria Inmobiliaria? @relation(fields: [inmobiliariaId], references: [id])

  // Esto evita duplicados logicos de la misma reserva pero habria que ver si hace falta o no
  @@unique([clienteId, loteId, fechaReserva], name: "uq_reserva_cliente_lote_fecha")
  @@index([loteId], name: "idx_reserva_lote")
  @@index([clienteId], name: "idx_reserva_cliente")
}

// LOTE
model Lote {
  id          Int           @id @default(autoincrement())
  tipo        TipoLote
  descripcion String?
  estado      EstadoLote    @default(DISPONIBLE)
  subestado   SubestadoLote @default(NO_CONSTRUIDO)
  fondo       Decimal?      @db.Decimal(8, 2)
  frente      Decimal?      @db.Decimal(8, 2)
  numPartido  Int           @default(62)
  superficie  Decimal?      @db.Decimal(10, 2)

  alquiler           Boolean?
  deuda              Boolean?
  precio             Decimal? @db.Decimal(12, 2)
  nombreEspacioComun String?
  capacidad          Int?

  ubicacion Ubicacion?

  fraccionId Int
  fraccion   Fraccion @relation(fields: [fraccionId], references: [id])

  propietarioId Int
  propietario   Persona @relation(fields: [propietarioId], references: [id])

  reserva Reserva[]

  createdAt DateTime  @default(now())
  updateAt  DateTime?
  Venta     Venta[]
}

model Ubicacion {
  id     Int  @id @default(autoincrement())
  loteId Int  @unique
  lote   Lote @relation(fields: [loteId], references: [id], onDelete: Cascade)

  calle  NombreCalle
  numero Int
}

model Fraccion {
  id     Int    @id @default(autoincrement())
  numero Int    @unique
  lotes  Lote[]
}

// VENTAS
model Venta {
  id             Int         @id @default(autoincrement())
  loteId         Int
  lote           Lote        @relation(fields: [loteId], references: [id], onDelete: Cascade)
  fechaVenta     DateTime
  monto          Decimal     @db.Decimal(12, 2)
  estado         EstadoVenta @default(INICIADA)
  plazoEscritura DateTime?
  tipoPago       String
  compradorId    Int
  comprador      Persona     @relation(fields: [compradorId], references: [id], onDelete: Cascade)
  vendedorId     Int         @default(0)
  createdAt      DateTime    @default(now())
  updateAt       DateTime?
  Inmobiliaria  Inmobiliaria[]
}

// Inmobiliaria
model Inmobiliaria {
  id          Int       @id @default(autoincrement())
  nombre      String
  razonSocial String
  comxventa   Decimal?  @db.Decimal(5, 2)
  contacto    String?
  createdAt   DateTime  @default(now())
  updateAt    DateTime?
  reservas     Reserva[]
  ventas      Venta[]

  userId    Int?      @unique
  user      User?     @relation(fields: [userId], references: [id])
}
