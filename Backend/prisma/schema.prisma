generator client {
  provider = "prisma-client-js"
  output   = "../src/generated/prisma"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

// ===================
// Enums del dominio
// ===================

enum Role {
  ADMINISTRADOR
  INMOBILIARIA
  GESTOR
  TECNICO
}

enum TipoLote {
  LOTE_VENTA
  ESPACIO_COMUN
}

enum EstadoLote {
  ALQUILADO
  DISPONIBLE
  EN_PROMOCION
  NO_DISPONIBLE
  RESERVADO
  VENDIDO
}

enum SubestadoLote {
  CONSTRUIDO
  NO_CONSTRUIDO
  EN_CONSTRUCCION
}

enum NombreCalle {
  REINAMORA
  MACA
  ZORZAL
  CAUQUEN
  ALONDRA
  JACANA
  TACUARITO
  JILGUERO
  GOLONDRINA
  CALANDRIA
  AGUILAMORA
  LORCA
  MILANO
}

enum EstadoReserva {
  ACTIVA
  CANCELADA
  ACEPTADA
}

enum EstadoVenta {
  INICIADA
  CON_BOLETO
  ESCRITURA_PROGRAMADA
  ESCRITURADO
}

enum TiposArchivos {
  BOLETO
  ESCRITURA
  PLANO
  IMAGEN
}

// ===================
// Modelos de dominio
// ===================

// Usuario
model User {
  id           Int           @id @default(autoincrement())
  username     String        @unique
  password     String
  role         Role
  email        String        @unique
  createdAt    DateTime      @default(now())
  persona      Persona?
  inmobiliaria Inmobiliaria?
  uplodedFiles Archivos[]
}

// Persona
model Persona {
  id        Int       @id @default(autoincrement())
  nombre    String
  apellido  String
  cuil      String
  contacto  String?
  userId    Int?      @unique
  user      User?     @relation(fields: [userId], references: [id])
  // Relación con Lote como propietario
  lotesPropios    Lote[]    @relation("PropietarioLotes")

  // --- Grupo familiar (auto-relación) ---
  jefeDeFamiliaId Int?
  jefeDeFamilia   Persona?  @relation("GrupoFamiliar", fields: [jefeDeFamiliaId], references: [id], onDelete: SetNull, onUpdate: Cascade)
  miembrosFamilia Persona[] @relation("GrupoFamiliar")

  // Relación con Lote como inquilino (alquilados)
  lotesAlquilados Lote[]    @relation("InquilinoLotes")
  createdAt DateTime  @default(now())
  updateAt  DateTime
  Venta     Venta[]
  Reserva   Reserva[]
}

// Reserva
model Reserva {
  id             Int      @id @default(autoincrement())
  fechaReserva   DateTime
  estado         EstadoReserva @default(ACTIVA)
  loteId         Int
  clienteId      Int
  inmobiliariaId Int?
  sena           Decimal? @db.Decimal(12, 2) // “seña” opcional, pero al parecer asi es mejor
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  // relaciones
  lote         Lote          @relation(fields: [loteId], references: [id])
  cliente      Persona       @relation(fields: [clienteId], references: [id])
  inmobiliaria Inmobiliaria? @relation(fields: [inmobiliariaId], references: [id])
  Venta        Venta[]

  // Esto evita duplicados logicos de la misma reserva pero habria que ver si hace falta o no
  @@unique([clienteId, loteId, fechaReserva], name: "uq_reserva_cliente_lote_fecha")
  @@index([loteId], name: "idx_reserva_lote")
  @@index([clienteId], name: "idx_reserva_cliente")
}

// LOTE
model Lote {
  id          Int           @id @default(autoincrement())
  tipo        TipoLote
  descripcion String?
  estado      EstadoLote    @default(DISPONIBLE)
  subestado   SubestadoLote @default(NO_CONSTRUIDO)
  fondo       Decimal?      @db.Decimal(8, 2)
  frente      Decimal?      @db.Decimal(8, 2)
  numPartido  Int           @default(62)
  superficie  Decimal?      @db.Decimal(10, 2)

  alquiler           Boolean?
  deuda              Boolean?
  precio             Decimal? @db.Decimal(12, 2)
  nombreEspacioComun String?
  capacidad          Int?

  ubicacion Ubicacion?

  fraccionId Int
  fraccion   Fraccion @relation(fields: [fraccionId], references: [id])

  // Propietario (obligatorio)
  propietarioId Int
  propietario   Persona @relation("PropietarioLotes", fields: [propietarioId], references: [id])

  // Inquilino (opcional)
  inquilinoId Int?
  inquilino   Persona? @relation("InquilinoLotes", fields: [inquilinoId], references: [id])

  reserva Reserva[]

  createdAt DateTime  @default(now())
  updateAt  DateTime?
  Venta     Venta[]
  archivos  Archivos[]
}

model Ubicacion {
  id     Int   @id @default(autoincrement())
  loteId Int?  @unique
  lote   Lote? @relation(fields: [loteId], references: [id])

  calle  NombreCalle
  numero Int
}

model Fraccion {
  id     Int    @id @default(autoincrement())
  numero Int    @unique
  lotes  Lote[]
}

// VENTAS
model Venta {
  id             Int           @id @default(autoincrement())
  loteId         Int
  lote           Lote          @relation(fields: [loteId], references: [id], onDelete: Restrict)
  fechaVenta     DateTime
  monto          Decimal       @db.Decimal(12, 2)
  estado         EstadoVenta   @default(INICIADA)
  plazoEscritura DateTime?
  tipoPago       String
  compradorId    Int
  comprador      Persona       @relation(fields: [compradorId], references: [id], onDelete: Restrict)
  inmobiliariaId Int?
  inmobiliaria   Inmobiliaria? @relation(fields: [inmobiliariaId], references: [id], onDelete: SetNull)
  reservaId      Int?
  reserva        Reserva?      @relation(fields: [reservaId], references: [id], onDelete: SetNull)
  createdAt      DateTime      @default(now())
  updateAt       DateTime?
}

// Inmobiliaria
model Inmobiliaria {
  id          Int       @id @default(autoincrement())
  nombre      String
  razonSocial String
  comxventa   Decimal?  @db.Decimal(5, 2)
  contacto    String?
  createdAt   DateTime  @default(now())
  updateAt    DateTime?
  reservas    Reserva[]
  ventas      Venta[]

  userId Int?  @unique
  user   User? @relation(fields: [userId], references: [id])
}

// Archivos

model Archivos {
  id              Int      @id @default(autoincrement())
  nombreArchivo   String
  linkArchivo     String
  tipo            TiposArchivos
  idLoteAsociado  Int
  lote            Lote     @relation(fields: [idLoteAsociado], references: [id], onDelete: Restrict)
  createdAt       DateTime @default(now())
  uploadedBy      String?
  user            User?     @relation(fields: [uploadedBy], references: [email])
}
