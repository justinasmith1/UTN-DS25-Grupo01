generator client {
  provider      = "prisma-client-js"
  output        = "../src/generated/prisma"
  binaryTargets = ["native", "debian-openssl-1.1.x", "debian-openssl-3.0.x", "linux-musl", "linux-musl-openssl-3.0.x"]
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

// ===================
// Enums del dominio
// ===================

enum Role {
  ADMINISTRADOR
  INMOBILIARIA
  GESTOR
  TECNICO
}

enum TipoLote {
  LOTE_VENTA
  ESPACIO_COMUN
}

enum EstadoLote {
  OPERATIVO
  ELIMINADO
  ALQUILADO
  CON_PRIORIDAD
  DISPONIBLE
  EN_PROMOCION
  NO_DISPONIBLE
  RESERVADO
  VENDIDO
}

enum SubestadoLote {
  CONSTRUIDO
  NO_CONSTRUIDO
  EN_CONSTRUCCION
}

enum NombreCalle {
  REINAMORA
  MACA
  ZORZAL
  CAUQUEN
  ALONDRA
  JACANA
  TACUARITO
  JILGUERO
  GOLONDRINA
  CALANDRIA
  AGUILAMORA
  LORCA
  MILANO
}

enum EstadoReserva {
  ACTIVA
  CANCELADA
  ACEPTADA
  RECHAZADA
  CONTRAOFERTA
  EXPIRADA
}

enum EstadoCobro {
  PENDIENTE
  EN_CURSO
  PAGO_COMPLETO
}

enum EstadoVenta {
  INICIADA
  CON_BOLETO
  ESCRITURADO
  CANCELADA
}

enum EstadoPrioridad {
  ACTIVA
  CANCELADA
  FINALIZADA
  EXPIRADA
}

enum OwnerPrioridad {
  INMOBILIARIA
  CCLF
}

enum EstadoOperativo {
  OPERATIVO
  ELIMINADO
}

enum TiposArchivos {
  BOLETO
  ESCRITURA
  PLANO
  IMAGEN
  OTRO
}

enum IdentificadorTipo {
  DNI
  CUIL
  CUIT
  PASAPORTE
  OTRO
}

enum PersonaCategoria {
  OPERATIVA
  MIEMBRO_FAMILIAR
}

enum EstadoAlquiler {
  ACTIVO
  FINALIZADO
}

// ===================
// Modelos de dominio
// ===================

// Usuario
model User {
  id           Int           @id @default(autoincrement())
  username     String        @unique
  password     String
  role         Role
  email        String        @unique
  createdAt    DateTime      @default(now())
  persona      Persona?
  inmobiliaria Inmobiliaria?
  uplodedFiles Archivos[]
}

// Persona
model Persona {
  id                 Int               @id @default(autoincrement())
  // Identificador nuevo (principal)
  identificadorTipo  IdentificadorTipo
  identificadorValor String
  // Datos personales (para personas físicas)
  nombre             String?
  apellido           String?
  // Datos para personas jurídicas
  razonSocial        String?
  // Estado operativo (unificado)
  estadoOperativo    EstadoOperativo   @default(OPERATIVO)
  fechaBaja          DateTime?
  // Categoría (OPERATIVA o MIEMBRO_FAMILIAR)
  categoria          PersonaCategoria  @default(OPERATIVA)
  // Contacto
  contacto           String?
  // Email (campo propio, separado de contacto)
  email              String?
  // Relación con User (opcional)
  userId             Int?              @unique
  user               User?             @relation(fields: [userId], references: [id])
  // Relación con Inmobiliaria (para clientes de inmobiliaria)
  inmobiliariaId     Int?
  inmobiliaria       Inmobiliaria?     @relation(fields: [inmobiliariaId], references: [id])
  // Legacy: campo cuil (mantener para compatibilidad, no usar en lógica nueva)
  cuil               String?

  // Relación con Lote como propietario
  lotesPropios Lote[] @relation("PropietarioLotes")

  // --- Grupo familiar (auto-relación) ---
  jefeDeFamiliaId Int?
  jefeDeFamilia   Persona?  @relation("GrupoFamiliar", fields: [jefeDeFamiliaId], references: [id], onDelete: SetNull, onUpdate: Cascade)
  miembrosFamilia Persona[] @relation("GrupoFamiliar")

  // Relación con Lote como inquilino (alquilados) - LEGACY: mantener para compatibilidad
  lotesAlquilados Lote[] @relation("InquilinoLotes")

  // Relación con Alquileres
  alquileres Alquiler[]

  createdAt DateTime @default(now())
  updateAt  DateTime

  Venta   Venta[]
  Reserva Reserva[]

  @@unique([identificadorTipo, identificadorValor])
  @@index([estadoOperativo])
  @@index([inmobiliariaId])
  @@index([categoria])
}

// Reserva
model Reserva {
  id                Int             @id @default(autoincrement())
  numero            String          @unique
  fechaReserva      DateTime
  estado            EstadoReserva   @default(ACTIVA)
  estadoPrevio      EstadoReserva?
  estadoOperativo   EstadoOperativo @default(OPERATIVO)
  fechaBaja         DateTime?
  loteId            Int
  clienteId         Int
  inmobiliariaId    Int?
  sena              Decimal?        @db.Decimal(12, 2)
  fechaFinReserva   DateTime        @default(now())
  loteEstadoAlCrear EstadoLote      @default(DISPONIBLE) // Guardamos el estado original del lote para restaurarlo al finalizar la reserva
  ventaId           Int?            @unique // ID de la venta que consumió esta reserva (nullable). Si no es null, la reserva está cerrada por venta
  createdAt         DateTime        @default(now())
  updatedAt         DateTime        @updatedAt

  // relaciones
  lote          Lote            @relation(fields: [loteId], references: [id])
  cliente       Persona         @relation(fields: [clienteId], references: [id])
  inmobiliaria  Inmobiliaria?   @relation(fields: [inmobiliariaId], references: [id])
  ventaConsumo  Venta?          @relation("VentaConsumeReserva", fields: [ventaId], references: [id], onDelete: SetNull)
  ofertas       OfertaReserva[]
  ofertaActual  Decimal         @db.Decimal(12, 2)
  ofertaInicial Decimal         @db.Decimal(12, 2)

  // Esto evita duplicados logicos de la misma reserva pero habria que ver si hace falta o no
  @@unique([clienteId, loteId, fechaReserva], name: "uq_reserva_cliente_lote_fecha")
  @@index([loteId], name: "idx_reserva_lote")
  @@index([clienteId], name: "idx_reserva_cliente")
  @@index([estadoOperativo], name: "idx_reserva_estado_operativo")
}

model OfertaReserva {
  id            Int            @id @default(autoincrement())
  reservaId     Int
  reserva       Reserva        @relation(fields: [reservaId], references: [id])
  monto         Decimal        @db.Decimal(12, 2)
  motivo        String?        @db.Text
  nombreEfector String
  efectorId     Int?
  ownerType     OwnerPrioridad
  createdAt     DateTime       @default(now())

  @@index([reservaId])
}

// LOTE
model Lote {
  id          Int           @id @default(autoincrement())
  numero      Int?
  mapId       String?       @unique
  tipo        TipoLote
  descripcion String?
  estado      EstadoLote    @default(DISPONIBLE)
  subestado   SubestadoLote @default(NO_CONSTRUIDO)
  fondo       Decimal?      @db.Decimal(8, 2)
  frente      Decimal?      @db.Decimal(8, 2)
  numPartido  Int           @default(62)
  superficie  Decimal?      @db.Decimal(10, 2)

  alquiler           Boolean?
  deuda              Boolean?
  precio             Decimal? @db.Decimal(12, 2)
  nombreEspacioComun String?
  capacidad          Int?

  ubicacion Ubicacion?

  fraccionId Int
  fraccion   Fraccion @relation(fields: [fraccionId], references: [id])

  // Propietario (obligatorio)
  propietarioId Int
  propietario   Persona @relation("PropietarioLotes", fields: [propietarioId], references: [id])

  // Inquilino (opcional) - LEGACY: mantener para compatibilidad, pero usar Alquiler para lógica nueva
  inquilinoId Int?
  inquilino   Persona? @relation("InquilinoLotes", fields: [inquilinoId], references: [id])

  // Relación con Alquileres
  alquileres Alquiler[]

  reserva     Reserva[]
  prioridad   Prioridad[]
  promociones Promocion[]

  createdAt DateTime   @default(now())
  updateAt  DateTime?
  Venta     Venta[]
  archivos  Archivos[]
}

model Ubicacion {
  id     Int   @id @default(autoincrement())
  loteId Int?  @unique
  lote   Lote? @relation(fields: [loteId], references: [id])

  calle  NombreCalle
  numero Int
}

model Fraccion {
  id     Int    @id @default(autoincrement())
  numero Int    @unique
  lotes  Lote[]
}

// VENTAS
model Venta {
  id                  Int             @id @default(autoincrement())
  numero              String          @unique
  loteId              Int
  lote                Lote            @relation(fields: [loteId], references: [id], onDelete: Restrict)
  fechaVenta          DateTime
  monto               Decimal         @db.Decimal(12, 2)
  estado              EstadoVenta     @default(INICIADA)
  estadoPrevio        EstadoVenta?
  estadoOperativo     EstadoOperativo @default(OPERATIVO)
  fechaBaja           DateTime?
  estadoCobro         EstadoCobro     @default(PENDIENTE)
  plazoEscritura      DateTime?
  fechaEscrituraReal  DateTime?
  fechaCancelacion    DateTime?
  motivoCancelacion   String?         @db.Text
  tipoPago            String
  compradorId         Int
  comprador           Persona         @relation(fields: [compradorId], references: [id], onDelete: Restrict)
  inmobiliariaId      Int?
  inmobiliaria        Inmobiliaria?   @relation(fields: [inmobiliariaId], references: [id], onDelete: SetNull)
  reservaConsumo      Reserva?        @relation("VentaConsumeReserva")
  createdAt           DateTime        @default(now())
  updateAt            DateTime?

  @@index([estadoOperativo], name: "idx_venta_estado_operativo")
}

// Inmobiliaria
model Inmobiliaria {
  id                    Int             @id @default(autoincrement())
  nombre                String
  razonSocial           String
  comxventa             Decimal?        @db.Decimal(5, 2)
  contacto              String?
  estadoOperativo       EstadoOperativo @default(OPERATIVO)
  fechaBaja             DateTime?
  maxPrioridadesActivas Int             @default(5)

  // Fechas de auditoria
  createdAt DateTime  @default(now())
  updateAt  DateTime?

  reservas    Reserva[]
  ventas      Venta[]
  prioridades Prioridad[]
  clientes    Persona[] // Personas que son clientes de esta inmobiliaria

  userId Int?  @unique
  user   User? @relation(fields: [userId], references: [id])

  @@index([estadoOperativo])
}

// Prioridad
model Prioridad {
  id                Int             @id @default(autoincrement())
  numero            String          @unique
  loteId            Int
  lote              Lote            @relation(fields: [loteId], references: [id])
  estado            EstadoPrioridad @default(ACTIVA)
  estadoOperativo   EstadoOperativo @default(OPERATIVO)
  ownerType         OwnerPrioridad
  inmobiliariaId    Int?
  inmobiliaria      Inmobiliaria?   @relation(fields: [inmobiliariaId], references: [id])
  fechaInicio       DateTime        @default(now())
  fechaFin          DateTime
  loteEstadoAlCrear EstadoLote      @default(DISPONIBLE) // Guardamos el estado original del lote para restaurarlo al finalizar la prioridad
  createdAt         DateTime        @default(now())
  updatedAt         DateTime        @updatedAt

  @@index([loteId], name: "idx_prioridad_lote")
  @@index([estado], name: "idx_prioridad_estado")
  @@index([fechaFin], name: "idx_prioridad_fecha_fin")
  @@index([estadoOperativo], name: "idx_prioridad_estado_operativo")
}

// Promocion
model Promocion {
  id     Int  @id @default(autoincrement())
  loteId Int
  lote   Lote @relation(fields: [loteId], references: [id], onDelete: Restrict)

  precioAnterior    Decimal    @db.Decimal(12, 2)
  precioPromocional Decimal    @db.Decimal(12, 2)
  estadoAnterior    EstadoLote
  inicio            DateTime   @default(now())
  fin               DateTime?
  activa            Boolean    @default(true)
  explicacion       String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([loteId])
  @@index([activa])
  @@index([fin])
}

// Archivos

model Archivos {
  id             Int           @id @default(autoincrement())
  nombreArchivo  String
  linkArchivo    String
  tipo           TiposArchivos
  idLoteAsociado Int
  lote           Lote          @relation(fields: [idLoteAsociado], references: [id], onDelete: Restrict)
  createdAt      DateTime      @default(now())
  uploadedBy     String?
  user           User?         @relation(fields: [uploadedBy], references: [email])
}

// Alquiler
model Alquiler {
  id          Int            @id @default(autoincrement())
  loteId      Int
  lote        Lote           @relation(fields: [loteId], references: [id], onDelete: Restrict)
  inquilinoId Int
  inquilino   Persona        @relation(fields: [inquilinoId], references: [id], onDelete: Restrict)
  estado      EstadoAlquiler @default(ACTIVO)
  fechaInicio DateTime       @default(now())
  fechaFin    DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  // Constraint parcial: solo un ACTIVO por lote (a nivel de aplicación, no de DB)
  // En PostgreSQL, usaríamos un índice parcial único, pero Prisma no lo soporta directamente
  // Se maneja a nivel de aplicación

  @@index([loteId], name: "idx_alquiler_lote")
  @@index([inquilinoId], name: "idx_alquiler_inquilino")
  @@index([estado], name: "idx_alquiler_estado")
}
